### 线程的创建

>1. 继承Thread类
>
>   1.1 定义一个类继承Thread
>
>   1.2 重写run()方法
>
>   1.3 创建子类对象(创建线程对象)
>
>   1.4 调用start()方法，开启线程并让线程执行，同时会通知jvm调用run()方法
>
>2. 实现Runnable接口
>
>   2.1 定义类实现Runnable接口
>
>   2.2 覆盖接口中的run方法，将线程任务代码定义到run方法中
>
>   2.3 创建Thread类的对象，将Runnable接口的子类对象作为参数传递给Thread类的构造函数
>
>   2.4 调用Thread类的start方法开启线程

>线程对象调用该run方法和调用start方法的区别
>
>- 调用run方法不开启线程，仅是普通的对象调用方法
>- 调用start方法开启线程，并让jvm调用run方法在开启的线程中执行

> 采用实现Runnable接口的好处
>
> - 避免了单继承的局限性
> - 实现Runnable接口更加符合面向对象，线程分为两部分，一部分是线程对象(Thread)，另一部分是线程任务(Runnable)。继承Thread类：线程对象和线程任务耦合在一起，一旦创建Thread类的子类对象，既是线程对象，又有线程任务。 

### 多线程内存

> 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间，进行方法的压栈和弹栈。当执行线程的任务结束了，线程自动在栈内存中释放了，所有执行的线程都结束了，进程就结束了。

### 线程的状态

### 线程的安全问题

###### 产生的原因

>1. 多个线程在操作共享的数据
>2. 线程任务操作共享数据的代码有多条

###### 解决思路

> 只要让一个线程在执行线程任务时将多条操作共享数据的代码执行完，在执行过程中不要让其他线程参与运算。

###### 实现方法

> 在Java中通过**同步代码块**来解决线程安全问题：`synchronized(对象){}`
>
> 同步的好处：解决多线程的安全问题
>
> 同步的弊端：
>
> - 降低了程序的性能
> - 可能会产生死锁
>
> 同步的前提：必须保证多个线程在同步中使用的是同一把锁
>
> **同步函数**
>
> - 同步函数的锁是固定的this
>
> **静态同步函数**
>
> - 使用的锁不是this,而是字节码文件对象(类名.class)

###### 死锁

> 情况一：当一个任务中有多个同步代码块，且同步代码块相互嵌套就有可能会出现死锁。

### 多线程间的通信

###### 生产者消费者

###### 等待唤醒机制

> `wait()`:会让线程处于等待状态，其实就是将线程临时存储到了线程池中
>
> `notify()`:会唤醒线程池中任意一个等待的线程
>
> `notifyAll()`:会唤醒线程池中所有等待的线程
>
> ​	**以上方法必须在同步中使用，因为必须要标识wait(),notify()方法所属的锁，同一个锁上的notify()，只能唤醒该锁上被wait()的方法**
>
> ​	**这些方法定义在Object类中，因为这些方法必须表示所属的锁，而锁对象是任意的，任意对象可以调用的方法只能是Object类中的方法**

###### jdk1.5后提供的新方法

> 提供了接口Lock来实现同步
>
> 将原先的监视器方法封装到了一个Condition对象中，获取监视器方法要先获取Condition对象。
>
> Condition中的监视器方法
>
> - await()
> - singal()
> - singalAll()