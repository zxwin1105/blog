> 面向对象三大特征：封装，继承，多态

### 一、类与对象的关系

>类：对事物的描述，需要体现属性和行为。
>
>对象：是类创建的实体(类的一个具体实现)，通过该实体调用属性和行为。

### 二、成员变量和局部变量的区别

> 1. 定义的位置不同  
>    - 成员变量定义在类中；局部变量定义在方法及语句中。
> 2. 在内存中的位置不同 
>    - 成员变量存储在堆内存的对象中；局部变量存储在栈内存的方法中
> 3. 生命周期不同  
>    - 成员变量随着对象的出现而出现，随着对象的消失而消失；局部变量随着方法的运行而出现，随着方法的弹栈而消失。
> 4. 初始化不同 
>    - 成员变量因为在堆内存中，所以有默认初始化值；局部变量没有默认初始化值，必须初始化后才可以使用。

### 三、封装

>表现形式
>
>1. 函数是一个最基本的封装体
>2. 类也是一个封装体
>
>封装的好处
>
>1. 提高了代码的复用性
>2. 隐藏了实现细节(私有化时封装的体现)，对外提供可以访问的方式

### 四、构造函数的细节

> 1. 一个类中可以有多个构造函数,以重载的形式存在;
> 2. 构造函数中也是有return语句的,用于结束方法;
> 3. 构造函数可以被private修饰;(当该类不希望被创建对象时，可以使用private修饰)

### 五、static关键字

###### static 的引入

> ​		创建对象是为了产生实例，并进行数据的封装。而调用功能时，却没有用到这些对象中封装的数据。该对象的创建就没有意义，虽然可以编译运行，但是在堆内存中空间较为浪费。这种情况就不建议创建对象。Java中通过使用static修饰符修饰的方法可以直接通过类名调用。

###### static 的使用时机

> 当功能不需要访问类中定义的成员变量(非静态的)时，该功能就需要静态修饰。

###### 静态方法的注意事项

> 1. 静态方法不能访问非静态成员；但是非静态方法	可以访问静态成员。
> 2. 静态方法中不允许出现this,super关键字。
>
> 原因
>
> - 静态时随着类的加载而加载；
> - 静态优先于对象存在，静态可以被对象共享；
> - 因为对象先存着于内存中无法访问后来的对象中的数据，所以静态无法访问非静态，而且内部无法书写this,因为此时对象有可能不存在，this没有任何指向

###### 静态变量

> 当该成员变量的值，每一个对象都一致时，就对该成员变量静态修饰。

###### 成员变量和静态变量区别

> 1. 所属的范围不同
>    - 静态变量所属于类；成员变量所属于对象。
> 2. 调用不同
>    - 静态变量可以被对象和类调用；成员变量只能被对象调用
> 3. 加载时机不同
>    - 静态变量随着类的加载而加载；成员变量随着对象加载而加载
> 4. 内存存储区域不同
>    - 静态变量存储在方法区中；成员变量存储在堆内存中

###### 静态代码块

> 类一加载，就需要做一些动作，不一定需要对象，这时可以使用静态代码块。
>
> 静态代码块的
>
> - 特点：随着类的加载而执行，仅执行一次
> - 作用：给类进行初始化
> - 在静态变量显示初始化以后再执行
>
> 

### 六、对象的创建过程

> 1. 加载 类.class 文件进入方法区，并进行空间分配
> 2. 如果有静态变量，先默认初始化，再显示初始化
> 3. 如果有静态代码块，要执行，仅一次
> 4. 通过new再堆内存中开辟空间，并明确首地址
> 5. 对对象中的属性进行默认初始化
> 6. 调用对应的构造函数进行初始化
> 7. 调用构造函数内部
>    1. 调用父类构造函数super();
>    2. 成员变量的显示初始化
>    3. 构造代码块初始化
>    4. 构造函数内的自定义内容初始化

### 七、继承

###### 继承的好处

> 提高了代码的复用性，让类与类产生了关系，给另一个多态提供了前提

###### 继承的体现

> 1. 在成员变量的体现
>    - 特殊情况：子类和父类中定义了一模式一样的成员变量时，都存在与子类对象中
>    - 子类访问父类同名变量通过super.xxx完成
>    - this 代表的是本类的引用
>    - super:代表的是父类的内存空间
> 2. 成员函数
>    - 子父类中定义了一模一样的函数，调用时运行子类函数。这种特性称之为函数的重写(override)
>    - 重写的注意事项
>      - 子类覆盖父类，必须保证权限大于或者等于父类的权限
>      - 静态覆盖静态
> 3. 构造函数
>    - 当子父类都有构造函数时，发现先执行了父类的构造函数，再执行了子类的构造函数
>    - 因为子类的所有构造函数中，第一行都有一个隐式的super()
>    - 是因为子类会继承父类的成员，在子类初始化时，必须先到父类中去初始化操作。 
>    - 当父类中没有空参构造函数时，子类的构造函数必须显示的执行super(argument)
>    - 细节：如果子类的构造函数第一行有this()，则构造函数第一行没有隐式的super();

### 八、final关键字

> final关键字可以修饰 类、方法、变量(包括成员变量，局部变量，静态变量)
>
> 1. final修饰的类是一个最终类，该类不能被继承
>
> 2. final修饰的方法是一个最终方法，该方法不能被重写
>
> 3. final修饰的变量是一个常量，该常量的值只能被赋值一次
>
>    当程序中有变量的值时固定不变的，要用final修饰(命名规则 字母全部大写用'_'隔开)

### 九、抽象类

> ​		在描述事物时，发现有些功能不具体，这些不具体的功能，可以用关键字abstract表示出来，被称为抽象方法，定义了抽象方法的类也必须时抽象类。
>
> 抽象类的特点
>
> 1. 抽象类一定是一个父类，是不断抽取而来的
> 2. 抽象类不能创建对象，但是抽象类有构造函数，用来给子类对象初始化
> 3. 抽象类中可以不定义抽象方法(目的时不让该类创建对象)
> 4. 关键字abstract不可以和private、static、final连用

### 十、接口

> 当一个抽象类中的方法都是抽象方法时，这时通过另一种形式来体现(接口 interface)
>
> 接口中成员固定修饰符
>
> - 定义变量：`public static final `;
> - 定义方法：`public abstract`
>
> 接口的特点
>
> 1. 接口不可以创建对象
> 2. 子类必须覆盖所有抽象方法，子类才可以实例化，否则子类是一个抽象类
>
> 接口最重要的体现：解决了继承的弊端，将多继承这种机制在Java中通过多实现完成
>
> - 多继承弊端：当多个父类中有相同的功能时，子类调用会产生不确定性，其核心原因在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主题。
> - 在接口中的所有功能都没有方法体，有子类来明确。
>
> 接口的作用
>
> - 接口的出现对功能实现了扩展
> - 接口的出现定义了规范
> - 接口的出现降低了耦合度
>
> 接口和抽象的区别
>
> ​	**类是用来描述事物的基本特性和功能；接口时负责描述事物的扩展功能。**
>
> 1. 抽象类是描述事物的基本功能，可以定义非抽象方法；接口中只能定义抽象方法
> 2. 类与类之间时继承关系(is a);类与接口之间时实现关系(like a)

### 十一、多态

> 多态的体现：父类或接口的引用指向子类对象对象
>
> 多态的好处：提高了程序的扩展性
>
> 多态的弊端：通过父类引用操作对象时，只能使用父类中的方法，不能使用子类中特有的方法
>
> 多态的前提
>
> 1. 必须有关系(继承/实现）
> 2. 子类必须覆盖父类方法
>
> 多态的转型
>
> 1. 向上转型：父类型引用执行子类对象，就是让子类对象进行了类型提升
>    - 向上转型的好处：提高了扩展性，隐藏了子类型
>    - 向上转型的弊端：不能使用子类的特有方法
> 2. 向下转型(强制转换)：需要使用子类的特有功能时，需要向下转型
>
> **注意：无论是向上或向下转型，最终都是子类对象做着类型改变**
>
> 向下转型注意事项E 
>
> - 向下转型时：由于不明确子类对象类型容易引发ClassCaseException异常，为了避免该问题，在向下转型时要做类型判断，使用`instanceof`

> 多态中成员调用的特点(开发中少用，面试会用)
>
> 1. 成员变量
>    - 当子父类中出现了同名变量时
>      - 多态调用时
>        - 编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量，没有则编译失败
>        - 运行时期：也是调用引用型变量所属类中的成员变量
> 2. 成员函数
>    - 编译时期：参考引用型变量所属的类，如果没有编译失败。
>    - 运行时期：参考对象所属的类
> 3. 静态函数
>    - 编译和运行都参考左边
>    - 静态函数是静态绑定到类上的

### 十二、内部类

> 内部类使用场景
>
> - 当描述事物时，事物的内部还有事物，这个内部的事物还在访问外部事物中的内容，这时就将这个事物通过内部类来描述
>
>  访问方式
>
> - 内部类可以直接访问外部类中的所有成员，包含私有的；而外部类要想访问内部类中的成员，必须创建内部类的对象
>
> 内部类被访问的方式
>
> 1. 内部类在成员位置上被访问方式 
>
>    - 成员是可以被指定的修饰符所修饰的
>
>      - public修饰的内部类可以被外界访问到，可以通过外部new其对象 (不常用)
>
>        `Outer.Inner in = new Outer().new Inner();`内部类是外部类的成员，创建对象需要借助外部类对象
>
>      - private  内部类只供其内部使用（常用）
>
>      - static修饰内部类：因为内部类是静态的所有不需要创建Outer的对象，直接创建内部类对象
>
>        `Outer.Inner in = new Outer.Inner();`
>
>        非静态内部类中 不允许定义静态成员，仅运去在非静态内部类中定义 静态常量 static final;如果想要在内部类中定义静态成员，内部类也必须是静态的
>
> **内部类可以直接访问外部类的成员是因为内部类持有了外部类的引用Outer.this,静态内部类不持有Outer.this而是直接使用外部类名访问。**
>
> 局部内部类-
>
> - 局部内部类，只能访问被final修饰的局部变量(方法和内部类对象生命周期不同)
>
> 内部类的延深
>
> - 内部类可以继承或实现外部其他类或接口  	
>
> 匿名内部类
>
> - 当内部类需要继承其他类时，可以简化成匿名内部类的形式
> - 